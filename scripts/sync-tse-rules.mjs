#!/usr/bin/env node

/**
 * Synchronize missing rule and test files from typescript-eslint into rslint.
 *
 * - Discovers remote rules in typescript-eslint at:
 *   - packages/eslint-plugin/src/rules/<rule>.ts
 *   - packages/eslint-plugin/tests/rules/<rule>.test.ts(x)
 * - Maps kebab-case rule names to snake_case directory/file names in rslint.
 * - Checks existing files in internal/rules and only fetches missing ones.
 * - Writes content as Go files with the original TS content wrapped in comments:
 *   - internal/rules/<snake>/<snake>.go
 *   - internal/rules/<snake>/<snake>_test.go
 *
 * Usage:
 *   node scripts/sync-tse-rules.mjs [--dry-run] [--only=<rule-name>]
 *
 * Optional env:
 *   - RSLINT_ROOT: Absolute path to repo root (defaults to cwd)
 *   - GITHUB_TOKEN or GH_TOKEN: For higher GitHub API rate limits
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

const GITHUB_API_BASE = 'https://api.github.com';
const RAW_BASE =
  'https://raw.githubusercontent.com/typescript-eslint/typescript-eslint/main';
const REMOTE_RULES_DIR = 'packages/eslint-plugin/src/rules';
const REMOTE_TESTS_DIR = 'packages/eslint-plugin/tests/rules';

const ROOT = process.env.RSLINT_ROOT || process.cwd();
const LOCAL_RULES_DIR = path.resolve(ROOT, 'internal', 'rules');

const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN || '';
const baseHeaders = {
  'User-Agent': 'rslint-sync-script',
  Accept: 'application/vnd.github+json',
  ...(token ? { Authorization: `Bearer ${token}` } : {}),
};

function toSnakeCase(kebab) {
  return kebab.replace(/-/g, '_');
}

async function listRemoteDirectory(relativePath) {
  const url = `${GITHUB_API_BASE}/repos/typescript-eslint/typescript-eslint/contents/${relativePath}`;
  const res = await fetch(url, { headers: baseHeaders });
  if (!res.ok) {
    throw new Error(
      `Failed to list ${relativePath}: ${res.status} ${res.statusText}`,
    );
  }
  return res.json();
}

async function getRemoteRuleNames() {
  const items = await listRemoteDirectory(REMOTE_RULES_DIR);
  return (
    items
      .filter(i => i.type === 'file' && i.name.endsWith('.ts'))
      .map(i => i.name)
      // exclude rule index aggregator and any non-rule helpers
      .filter(name => name !== 'index.ts')
      .map(name => name.replace(/\.ts$/, ''))
      .sort()
  );
}

async function getRemoteTestsMap() {
  const items = await listRemoteDirectory(REMOTE_TESTS_DIR);
  const map = new Map(); // ruleName (kebab) -> 'ts' | 'tsx'
  for (const i of items) {
    if (i.type !== 'file') continue;
    const m = i.name.match(/^(.+)\.test\.(tsx?)$/);
    if (m) map.set(m[1], m[2]);
  }
  return map;
}

async function readLocalState() {
  const state = new Map(); // snake -> { ruleExists, testExists }
  let dirents = [];
  try {
    dirents = await fs.readdir(LOCAL_RULES_DIR, { withFileTypes: true });
  } catch (e) {
    // If the directory doesn't exist yet, treat as empty
    if (e && e.code !== 'ENOENT') throw e;
  }
  for (const d of dirents) {
    if (!d.isDirectory()) continue;
    const snake = d.name;
    const rulePath = path.join(LOCAL_RULES_DIR, snake, `${snake}.go`);
    const testPath = path.join(LOCAL_RULES_DIR, snake, `${snake}_test.go`);
    const [ruleExists, testExists] = await Promise.all([
      fs
        .access(rulePath)
        .then(() => true)
        .catch(() => false),
      fs
        .access(testPath)
        .then(() => true)
        .catch(() => false),
    ]);
    state.set(snake, { ruleExists, testExists });
  }
  return state;
}

async function fetchRawText(relativePath) {
  const url = `${RAW_BASE}/${relativePath}`;
  const headers = token
    ? { ...baseHeaders, Accept: 'application/vnd.github.raw' }
    : baseHeaders;
  const res = await fetch(url, { headers });
  if (!res.ok) return null;
  return res.text();
}

function buildGoFile(packageName, srcRelativePath, content, kind) {
  const header = [
    '// Code generated by scripts/sync-tse-rules.mjs; DO NOT EDIT.',
    `// Source: typescript-eslint/${srcRelativePath}`,
    `// Kind: ${kind}`,
    `// Retrieved: ${new Date().toISOString()}`,
    '',
    `package ${packageName}`,
    '',
  ].join('\n');

  const normalized = content.replace(/\r\n/g, '\n');
  const body = normalized
    .split('\n')
    .map(line => `// ${line}`)
    .join('\n');
  return header + body + '\n';
}

async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

async function main() {
  const args = new Set(process.argv.slice(2));
  const dryRun = args.has('--dry-run');
  const onlyArg = Array.from(args).find(a => a.startsWith('--only='));
  const onlyRule = onlyArg ? onlyArg.slice('--only='.length) : null; // kebab-case

  console.log(`Local rules directory: ${LOCAL_RULES_DIR}`);
  const [remoteRules, remoteTestsMap, localState] = await Promise.all([
    getRemoteRuleNames(),
    getRemoteTestsMap(),
    readLocalState(),
  ]);

  const candidates = onlyRule
    ? remoteRules.filter(r => r === onlyRule)
    : remoteRules;

  let created = 0;
  let skipped = 0;
  let errors = 0;

  for (const ruleName of candidates) {
    const snake = toSnakeCase(ruleName);
    const pkg = snake;
    const dir = path.join(LOCAL_RULES_DIR, snake);
    const ruleGo = path.join(dir, `${snake}.go`);
    const testGo = path.join(dir, `${snake}_test.go`);
    const local = localState.get(snake) || {
      ruleExists: false,
      testExists: false,
    };

    const needRule = !local.ruleExists;
    const needTest = !local.testExists;
    if (!needRule && !needTest) {
      skipped++;
      continue;
    }

    const ruleSrcRel = `${REMOTE_RULES_DIR}/${ruleName}.ts`;
    const testExt = remoteTestsMap.get(ruleName) || 'ts';
    const testSrcRel = `${REMOTE_TESTS_DIR}/${ruleName}.test.${testExt}`;

    const [ruleTs, testTs] = await Promise.all([
      needRule ? fetchRawText(ruleSrcRel) : Promise.resolve(null),
      needTest ? fetchRawText(testSrcRel) : Promise.resolve(null),
    ]);

    try {
      await ensureDir(dir);

      if (needRule) {
        if (ruleTs) {
          const goText = buildGoFile(pkg, ruleSrcRel, ruleTs, 'rule');
          if (dryRun) {
            console.log(`[dry-run] Would write ${ruleGo}`);
          } else {
            await fs.writeFile(ruleGo, goText, 'utf8');
            console.log(`Wrote ${ruleGo}`);
          }
          if (!dryRun) created++;
        } else {
          console.warn(`Remote rule missing or failed to fetch: ${ruleName}`);
        }
      }

      if (needTest) {
        if (testTs) {
          const goText = buildGoFile(pkg, testSrcRel, testTs, 'test');
          if (dryRun) {
            console.log(`[dry-run] Would write ${testGo}`);
          } else {
            await fs.writeFile(testGo, goText, 'utf8');
            console.log(`Wrote ${testGo}`);
          }
          if (!dryRun) created++;
        } else {
          console.warn(`Remote test missing or failed to fetch: ${ruleName}`);
        }
      }
    } catch (e) {
      errors++;
      console.error(`Error writing files for ${snake}:`, e);
    }
  }

  console.log(`Done. created=${created} skipped=${skipped} errors=${errors}`);
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});
